<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/blog/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1" />






<meta name="description" content="写在前面
最近工作中又遇到了GIL和多线程的问题，借此机会重新梳理一下。大致脉络仿照陈儒的《Python源码剖析》第15章Python多线程机制，但会将平台转移到Linux下的Pthread线程库上。主要介绍CPython解释器的C实现，具体的Python库(thread,threading)的介绍可以参考Python Threading Module。同时会介绍下相关函数在Linux平台中的表现">
<meta property="og:type" content="article">
<meta property="og:title" content="python中的多线程和GIL锁">
<meta property="og:url" content="http://fanchao01.github.io/blog/2014/12/26/python-GIL/index.html">
<meta property="og:site_name" content="Blog My Minds">
<meta property="og:description" content="写在前面
最近工作中又遇到了GIL和多线程的问题，借此机会重新梳理一下。大致脉络仿照陈儒的《Python源码剖析》第15章Python多线程机制，但会将平台转移到Linux下的Pthread线程库上。主要介绍CPython解释器的C实现，具体的Python库(thread,threading)的介绍可以参考Python Threading Module。同时会介绍下相关函数在Linux平台中的表现">
<meta property="og:updated_time" content="2016-08-25T03:44:26.827Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python中的多线程和GIL锁">
<meta name="twitter:description" content="写在前面
最近工作中又遇到了GIL和多线程的问题，借此机会重新梳理一下。大致脉络仿照陈儒的《Python源码剖析》第15章Python多线程机制，但会将平台转移到Linux下的Pthread线程库上。主要介绍CPython解释器的C实现，具体的Python库(thread,threading)的介绍可以参考Python Threading Module。同时会介绍下相关函数在Linux平台中的表现">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://fanchao01.github.io/blog/2014/12/26/python-GIL/"/>

  <title> python中的多线程和GIL锁 | Blog My Minds </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7f592ce66e56bd7572224ba7c19a8f40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Blog My Minds</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                python中的多线程和GIL锁
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-26T00:00:00-08:00" content="2014-12-26">
              2014-12-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/12/26/python-GIL/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/26/python-GIL/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><hr>
<p>最近工作中又遇到了GIL和多线程的问题，借此机会重新梳理一下。大致脉络仿照陈儒的《Python源码剖析》第15章<code>Python多线程机制</code>，但会将平台转移到Linux下的Pthread线程库上。主要介绍CPython解释器的C实现，具体的Python库(thread,threading)的介绍可以参考<a href="/2014/05/15/python_threading/">Python Threading Module</a>。同时会介绍下相关函数在Linux平台中的表现等。</p>
<h3 id="python中的GIL锁"><a href="#python中的GIL锁" class="headerlink" title="python中的GIL锁"></a>python中的GIL锁</h3><hr>
<p>CPython中有一个全局的解释器锁叫做<code>GIL</code>（global interpreter lock），对解释器中的共享变量提供保护。GIL不是必须的，可以通过对每个资源单独加锁的方式去掉GIL，也就是将GIL换成更细粒度的锁。实际上也有这么做的，不过结果是在单核上的性能不如有GIL的版本(2倍的差距)，大量的细粒度锁的开销消耗了大量的资源。所以，Guido有篇很著名的文章<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=214235" target="_blank" rel="external">It isn’t easy to remove GIL</a>讨论这个问题。如果去掉GIL需要考虑两件事：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>不会降低Python在单核上的性能；</div><div class="line"><span class="bullet">2. </span>需要考虑如何将现在大量的库进行迁移；</div></pre></td></tr></table></figure>
<p>总之从Python3的尴尬处境可以简单知道，CPython中的GIL是不可能去除的。</p>
<p>做技术很多时候是在折中(tradeoff)，就比如当年Linux用宏内核架构会被认为过时一样。性能高、简单（实现简单）好用（使用快速）几乎立于不败之地，更多参考见这本书<a href="http://web.mit.edu/~simsong/www/ugh.pdf" target="_blank" rel="external">The Unix Hackers Handbook</a>。</p>
<h3 id="GIL锁的类型以及语义"><a href="#GIL锁的类型以及语义" class="headerlink" title="GIL锁的类型以及语义"></a>GIL锁的类型以及语义</h3><hr>
<p>代码中的<code>interpreter_lock</code>就是全局解释器锁，类型为<code>PyThread_type_lock</code>，简单的void指针，然后再根据不同的平台转换成对应类型的指针，在Linux中的类型是<code>pthread_lock</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//python2.7.5/Python/ceval.c</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock interpreter_lock = <span class="number">0</span>; <span class="comment">/* This is the GIL */</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock pending_lock = <span class="number">0</span>; <span class="comment">/* for pending calls */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> main_thread = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">PyEval_ThreadsInitialized</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> interpreter_lock != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">PyEval_InitThreads</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (interpreter_lock)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    interpreter_lock = PyThread_allocate_lock();</div><div class="line">    PyThread_acquire_lock(interpreter_lock, <span class="number">1</span>);</div><div class="line">    main_thread = PyThread_get_thread_ident();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//python2.7.5/Python/Thread_pthread.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">/* 0=unlocked, 1=locked */</span></div><div class="line">    <span class="keyword">char</span>             locked; </div><div class="line">    <span class="comment">/* a &lt;cond, mutex&gt; pair to handle an acquire of a locked lock */</span></div><div class="line">    <span class="keyword">pthread_cond_t</span>   lock_released;</div><div class="line">    <span class="keyword">pthread_mutex_t</span>  mut;</div><div class="line">&#125; pthread_lock;</div></pre></td></tr></table></figure>
<p>之所以需要<code>pthread_lock</code>而不是直接使用原生的<code>pthread_mutex_t</code>，是因为Pthread的标准有未定义的(undefined)部分，主要是：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 一个已经获取锁的线程再次获取同一个锁时的表现；</div><div class="line">(同一个线程多次调用pthread_mutex_lock，在linux中默认类型的锁第二次调用总会堵塞)</div><div class="line"><span class="number">2.</span>一个已经锁住的锁，被其他线程释放时的表现；</div><div class="line">(其他线程调用pthread_mutex_unlock，在linux中默认类型的锁总会被释放）</div></pre></td></tr></table></figure>
<p>因此，Python实现了<code>pthread_lock</code>规避标准中的未定义部分。<code>pthread_lock</code>分为3个成员：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> char locked：是否锁住的标志，每次加锁需要竞争此标志，如果为<span class="number">1</span>就是已经锁住，加锁的线程返回失败非<span class="number">0</span>或者等待；</div><div class="line"><span class="number">2.</span> pthread_cond_t lock_released：锁的等待队列，请求锁时带有waitflag的线程会等待在该条件变量上；</div><div class="line"><span class="number">3.</span> pthread_mutex_t mut：锁本身；</div></pre></td></tr></table></figure>
<p>从上面的结构可以看到一个共识，加锁与代码之间的关系是为了使不同进程/线程串行执行代码，串行执行的结果就是共享资源操作结果的一致性。保证并行执行的正确性有几种不同的方法：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>使程序串行执行临界区：加锁、信号、条件</div><div class="line"><span class="bullet">2. </span>资源本身保证原子性：原子操作、无锁队列</div><div class="line"><span class="bullet">3. </span>去掉共享资源：函数式编程</div></pre></td></tr></table></figure>
<p><code>pthread_lock</code>有1组4个函数(接口)调用，分别是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>PyThread<span class="emphasis">_allocate_</span>lock: 分配一个锁；</div><div class="line"><span class="bullet">2. </span>PyThread<span class="emphasis">_free_</span>lock: free一个锁；</div><div class="line"><span class="bullet">3. </span>PyThread<span class="emphasis">_acquire_</span>lock(lock, waitflag):获取锁，waitflat=1时没有获取锁则等待；</div><div class="line">(waitflag=0，实现了pthread<span class="emphasis">_mutex_</span>trylock的语义；waitflag=1实现了pthread<span class="emphasis">_mutex_</span>lock的语义）</div><div class="line"><span class="bullet">4. </span>PyThread<span class="emphasis">_release_</span>lock: 总是成功释放锁，并且唤醒至少1个在等待锁的线程；</div><div class="line">(PyThread<span class="emphasis">_release_</span>lock实现中即使pthread<span class="emphasis">_mutex_</span>lock失败也会把locked恢复为0）</div></pre></td></tr></table></figure>
<p>Python中只使用了默认类型的锁，<code>pthread_mutex_init</code>中的第二个参数为NULL，mut本身是一个多次请求会等待的锁，不过Python本身不使用等待的语义。<code>Phtread_lock</code>和一组操作函数创造了一个这样的线程锁：通过waitflag指定获取锁时是否等待，成功获取返回0，失败返回非0；释放锁总能成功并唤醒至少1个等待锁的线程。</p>
<p>最后补充一下<code>PyThread_allocate_lock</code>中会调用<code>PyThread_init_thread</code>，进而调用<code>PyThread__init_thread</code>进行线程初始化。这是因为有些平台上进程和线程是完全分离的概念，需要调用相应的函数启动多线程库。在Linux的Pthread平台下是一进程多线程的模型，默认情况下一个进程也是一个线程，因此在这种情况下<code>PyThread__init_thread</code>是空的函数，完全不需要启动线程库的动作。</p>
<h3 id="python中的线程"><a href="#python中的线程" class="headerlink" title="python中的线程"></a>python中的线程</h3><hr>
<p>Python中通过thread等Python库启动的线程就是一个普通的Pthread线程，与C程序中调用<code>pthread_create</code>启动的线程没有本质区别，只不过Python中同一时间只有一个线程在运行，具体哪个线程能运行通过竞争GIL决定的。Python中线程的本质：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 同一时间只有一个Python线程（确切的说是虚拟机）运行，只能使用<span class="number">1</span>个CPU核心；</div><div class="line"><span class="number">2.</span> 不同线程的调度（哪个线程竞争到了GIL）完全由Python所在的操作系统决定；</div></pre></td></tr></table></figure>
<h3 id="python启动"><a href="#python启动" class="headerlink" title="python启动"></a>python启动</h3><hr>
<p>python中的线程启动通过<code>thread.start_new/start_new_thread</code>函数，然后调到CPython中的<code>thread_PyThread_start_new_thread</code>。这个函数主要处理用户调用时传入的参数，然后将启动函数和参数包装入bootstate结构，然后以<code>t_bootstrap</code>启动原生线程（linux下的pthread线程）。需要bootstate的主要原因有两点：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>python不能直接以用户设置的函数启动线程，需要做一些处理；</div><div class="line"><span class="bullet">2. </span>原生的pthread线程pthread_create函数只能接受一个参数；</div><div class="line">(在linux c编程中创建线程需要传入多个参数也需要将过个参数封装到单个结构中）</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> PyMethodDef thread_methods[] = &#123;</div><div class="line">    &#123;<span class="string">"start_new_thread"</span>,        (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"start_new"</span>,               (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从调用thread模块一直到<code>PyThread_start_new_thread</code>的线程都是主线程在运行；调用<code>pthread_create</code>然后进入<code>t_bootstrap</code>的线程是子线程。先看下主线程的调用路径，主路径通过<code>pthread_create</code>创建了子线程然后返回。注意这个时候主线程是拿者GIL锁的。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>python2.<span class="number">7.6</span><span class="regexp">/python/</span>Threadmodule.c</div><div class="line">thread_PyThread_start_new_thread</div><div class="line">	_PyThreadState_Preallock</div><div class="line">		new_threadstate</div><div class="line">		(设置threadstate，注意这个时候thread_id是主线程的id)</div><div class="line"></div><div class="line">	PyEval_InitThreads</div><div class="line">	（分配和获取GIL锁）</div><div class="line"></div><div class="line">	PyThread_start_new_thread</div><div class="line">		pthread_create</div><div class="line">		pthread_detach</div><div class="line"></div><div class="line">	PyInt_FromLong (返回）</div></pre></td></tr></table></figure>
<p>这里面需要注意一点，主线程创建子线程后就detach了，所以Python中的子线程都是分离的。然后看下子线程的调用路径，需要说明从<code>pthread_create</code>创建子线程开始运行到<code>t_bootstrap</code>中的<code>PyEval_AcquireThread</code>的这段代码是没有运行在Python的虚拟机中的，也就是说这段代码和GIL没有关系，在这期间主线程和子线程（在多核机器中）是可以同时运行的(不排除争夺其它的锁而导致挂起)。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>python2.<span class="number">7.6</span><span class="regexp">/python/</span>threadmodule.c</div><div class="line">t_bootstrap</div><div class="line">	PyThread_get_thread_ident</div><div class="line">	（这个时候将ident设置为真正的子线程的ident）</div><div class="line"></div><div class="line">	_PyThreadState_Init</div><div class="line">		_PyGILState_NoteThreadState</div><div class="line">			PyThread_set_key_value</div><div class="line">				find_key</div><div class="line">	（这段代码是将threadstate设置为每个线程的私有变量。主要做debug用。</div><div class="line">	 线程私有变量是这样一种变量，每个线程中的变量名是一样的，但是具体的值和线程相关，而且相互之间透明。</div><div class="line">	 在linux Pthread中由库直接提供支持。</div><div class="line">	 Python在其他平台中自己也实现了一个，可以看成一个ident:value的字典，但是每个线程只能取到自己ident上的值）</div><div class="line"></div><div class="line">	PyEval_AcquireThread</div><div class="line">		PyThread_acquire_lock</div><div class="line">		（等待获取GIL)</div><div class="line">		PyThread_State_Swap</div><div class="line">		（设置当前的全局变量 _PyThreadState_Current。每个Python线程在退出前必须调用这个函数换出自己，运行前调用换入自己）</div><div class="line"></div><div class="line">	PyEval_CallObjectWithKeywords</div><div class="line">		PyObject_call</div><div class="line">			<span class="keyword">func</span>-&gt;ob_type-&gt;tp_call</div><div class="line"></div><div class="line">	PyThreadState_Clear</div><div class="line"></div><div class="line">	PyThreadState_DeleteCurrent</div><div class="line">		PyThread_delete_key_value</div><div class="line">		PyEval_ReleaseLock</div><div class="line">		（释放GIL锁）</div><div class="line"></div><div class="line">	PyThread_exit_thread</div><div class="line">		<span class="keyword">exit</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>上面是子线程的调用路径。到这里还有两个问题没有解决，第一个是子线程如何进入虚拟机运行的（进入<code>PyEval_EvalFrame</code>);第二个是主线程何时释放GIL以便子线程在<code>t_bootstrap</code>中获取到而运行。</p>
<h4 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h4><p>先说第一个问题，在子线程调用路径中最后会调用<code>tp_call</code>，假设用户的子线程函数是函数，类似下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(x)</span>:</span></div><div class="line">	do_something_with(x)</div><div class="line"></div><div class="line">tpid = thread.start_new_thread(myfunc, (<span class="number">1</span>,))</div></pre></td></tr></table></figure>
<p>那么<code>tp_call</code>对应的是Python实现的<code>function_call</code>函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//python2.7.6/python/funcobject.c</span></div><div class="line"></div><div class="line">PyTypeObject PyFunction_Type = &#123;</div><div class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</div><div class="line">    <span class="string">"function"</span>,</div><div class="line"> 	...</div><div class="line">    function_call,                             <span class="comment">/* tp_call */</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>function_call</code>也在同一个文件中定义，它的调用路径见下。从中可以看到，每个线程对应一个Frame对象，也就是一个Python虚拟机，而不是一个Python虚拟机对应多个Python线程。（不像CPU那样，每个CPU对应多个线程，每个线程通过保存上下文设置寄存器进行切换）。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function_call</div><div class="line">	PyEval_EvalCodeEx</div><div class="line">	（获取<span class="function"><span class="keyword">func</span>字节码中存储的全局、局部变量、参数、闭包等等）</span></div><div class="line">		PyFrame_new</div><div class="line">		（创建新的Frame对象，Python虚拟机）</div><div class="line">		PyEval_EvalFrame</div><div class="line">		（运行创建的虚拟机）</div></pre></td></tr></table></figure>
<h4 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h4><p>第二个问题，主线程何时释放GIL锁。Python代码在虚拟机Frame中运行，其中有个变量<code>_Py_Ticker</code>。当<code>_Py_Ticker</code>小于0时，Python会释放GIL锁进行一次Python线程的调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">if</span> (-<span class="number">-_</span>Py_Ticker &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (*next_instr == SETUP_FINALLY) &#123;</div><div class="line">                <span class="comment">/* Make the last opcode before</span></div><div class="line">                   a try: finally: block uninterruptible. */</div><div class="line">                <span class="keyword">goto</span> fast_next_opcode;</div><div class="line">            &#125;</div><div class="line">            <span class="number">_</span>Py_Ticker = <span class="number">_</span>Py_CheckInterval;</div><div class="line">            tstate-&gt;tick_counter++;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_TSC</span></div><div class="line">            ticked = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">if</span> (pendingcalls_to_do) &#123;</div><div class="line">                <span class="keyword">if</span> (Py_MakePendingCalls() &lt; <span class="number">0</span>) &#123;</div><div class="line">                    why = WHY_EXCEPTION;</div><div class="line">                    <span class="keyword">goto</span> on_error;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (pendingcalls_to_do)</div><div class="line">                    <span class="comment">/* MakePendingCalls() didn't succeed.</span></div><div class="line">                       Force early re-execution of this</div><div class="line">                       "periodic" code, possibly after</div><div class="line">                       a thread switch */</div><div class="line">                    <span class="number">_</span>Py_Ticker = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (interpreter_lock) &#123;</div><div class="line">                <span class="comment">/* Give another thread a chance */</span></div><div class="line">				<span class="comment">//这里是一次GIL锁的释放和获取，子线程有机会获取GIL得以运行</span></div><div class="line">                <span class="keyword">if</span> (PyThreadState_Swap(<span class="literal">NULL</span>) != tstate)</div><div class="line">                    Py_FatalError(<span class="string">"ceval: tstate mix-up"</span>);</div><div class="line">                PyThread_release_lock(interpreter_lock);</div><div class="line"></div><div class="line">                <span class="comment">/* Other threads may run now */</span></div><div class="line"></div><div class="line">                PyThread_acquire_lock(interpreter_lock, <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (PyThreadState_Swap(tstate) != <span class="literal">NULL</span>)</div><div class="line">                    Py_FatalError(<span class="string">"ceval: orphan tstate"</span>);</div></pre></td></tr></table></figure>
<p>需要说明几点:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> GIL锁的粒度是每个Python指令，在一个Python指令中的操作是原子操作；</div><div class="line"><span class="number">2.</span> PyEval_EvalFrame中有一些指令运行后会跳到fast_next_opcode，跳过了GIL调度的代码区，所以这些指令和紧接下来的一个指令都是原子操作；</div><div class="line">（例如 x = <span class="number">1</span>，依赖这种细微的具体实现编程是不可取的，只要记住一个Python指令是原子操作足已）；</div><div class="line"><span class="number">3.</span> 每次Pyhon线程调度的指令数不一定整好是_Py_CheckInterval（<span class="number">100</span>）个，有些指令会跳过释放GIL的代码区；</div><div class="line"><span class="number">4.</span> Python线程最后由谁竞争到了GIL完全由操作系统决定，也就是具体哪个线程执行由操作系统决定，Python只管释放/获取一次GIL锁；</div><div class="line"><span class="number">5.</span> 在线程创建和销毁的代码区有一部分不运行在Frame中，这时Python中多个线程可能同时运行；</div></pre></td></tr></table></figure>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>上面提到Pthread线程和Python线程，按照CPython实现来看，Pthread线程和Python是一一对应的。称为Python线程侧重于正在运行Python代码时的线程(<code>PyEval_EvalFrame</code>部分）；称为Pthread线程侧重于CPython中线程的创建/销毁时的线程，等同起来看也没有任何问题。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2014/12/08/ruby-my-opinions/" rel="next" title="我对Ruby的一些观点">
                <i class="fa fa-chevron-left"></i> 我对Ruby的一些观点
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2015/01/09/smartisan-white-t1/" rel="prev" title="评论-白色锤子(smartisan T1)">
                评论-白色锤子(smartisan T1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2014/12/26/python-GIL/"
           data-title="python中的多线程和GIL锁" data-url="http://fanchao01.github.io/blog/blog/2014/12/26/python-GIL/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/blog/images/avatar.gif"
               alt="FanChao" />
          <p class="site-author-name" itemprop="name">FanChao</p>
          <p class="site-description motion-element" itemprop="description">Enjoin it!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/blog/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python中的GIL锁"><span class="nav-number">2.</span> <span class="nav-text">python中的GIL锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL锁的类型以及语义"><span class="nav-number">3.</span> <span class="nav-text">GIL锁的类型以及语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python中的线程"><span class="nav-number">4.</span> <span class="nav-text">python中的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python启动"><span class="nav-number">5.</span> <span class="nav-text">python启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一个问题"><span class="nav-number">5.1.</span> <span class="nav-text">第一个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二个问题"><span class="nav-number">5.2.</span> <span class="nav-text">第二个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充"><span class="nav-number">5.3.</span> <span class="nav-text">补充</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FanChao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/blog/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fanchao01"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/blog/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/blog/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
